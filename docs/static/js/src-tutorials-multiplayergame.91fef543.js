(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{"./src/tutorials/multiplayergame.mdx":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return d});var a=t("./node_modules/react/index.js"),o=t.n(a),r=t("./node_modules/@mdx-js/tag/dist/index.js");function s(e){return(s="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function c(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}function i(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function l(e,n){return!n||"object"!==s(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function p(e){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function m(e,n){return(m=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var d=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=l(this,p(n).call(this,e))).layout=null,t}var t,a,s;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&m(e,n)}(n,o.a.Component),t=n,(a=[{key:"render",value:function(){var e=this.props,n=e.components;c(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"writing-a-multiplayer-game-with-shared-world-state"}},"Writing a multiplayer game with shared world state."),o.a.createElement(r.MDXTag,{name:"p",components:n},'Typically a multiplayer game is characterized by having a shared world which all players can affect. It\'s also very common to have a coordinate system for a shared world. A very simple implementation of such a shared world is a simple key value mapping from coordinates to the state of the world at given coordinates.\nIn this tutorial we will write a very simple game with a shared world state. The only property that each world location supports is the color, and the world itself is a square playfield. Some of you may recognize this as "place", which made its way aroudn the Internet a while ago. '),o.a.createElement(r.MDXTag,{name:"p",components:n},"There is a working functional solution here ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://studio.nearprotocol.com/?f=natqgjb1b"}},"https://studio.nearprotocol.com/?f=natqgjb1b"),". Feel free to check it out and run it any time!"),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"step-1----start-a-new-fiddle-in-nearstudio"}},"Step 1 -- Start a new fiddle in NEARstudio"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Go to ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://studio.nearprotocol.com/"}},"https://studio.nearprotocol.com/")," and start a new project (fiddle) by selecting Token Smart Contract in AssemblyScript + Nearlib. You can try running this application right away to see the code interacting with the blockchain!"),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"step-2---write-a-smart-contract"}},"Step 2 - Write a smart contract"),o.a.createElement(r.MDXTag,{name:"p",components:n},"In this simple game, we need only two actions: view the world state, and make changes to the state at particular coordinates.\nIn a more complex game with a large world, it may be important to not return the state of the whole world, but our game is small and simple enough that we don't have to worry about this.\nNavigate to assembly/main.ts, and implement the following functions: setCoords and getCoords to operate on a single coordinate in the world. You will need to use globalStorage setItem and getItem functions. "),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"export function setCoords(coords: string, value: string): void {\n  globalStorage.setItem(coords, value);\n}\n\nexport function getCoords(coords: string): string {\n  return globalStorage.getItem(coords);\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"We also need a getMap function, which returns the full state of the game (we don't want to be making a separate call for every coordinate!)"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'export function getMap(): string {\n  let num_rows = 10;\n  let num_cols = 10;\n  let total_cells = num_rows * num_cols;\n  var arrResult:string[] = new Array(total_cells);\n  let i = 0;\n  for (let row=0; row<num_rows; row++) {\n    //let cellEntry = "";\n    for (let col=0; col<num_cols; col++) {\n      let cellEntry = globalStorage.getItem(near.str(row) + "," + near.str(col));\n      if (cellEntry == null) {\n        cellEntry = "000000";\n      }\n      if (col < num_cols - 1) {\n        cellEntry = cellEntry.concat(",".toString());\n      }\n      arrResult[i] = cellEntry;\n      i++;\n    }\n    if (row < num_rows - 1) {\n      arrResult[i-1] = arrResult[i-1].concat(";".toString());\n    }\n  }\n\n  let result = arrResult.join("");\n  return result as string;\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"step-2----write-a-couple-of-tests-for-the-contract"}},"Step 2 -- Write a couple of tests for the contract"),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can test the contract right away by writing some code in javascript. Open main.js and modify it to call the functions that we just wrote."),o.a.createElement(r.MDXTag,{name:"p",components:n},"First let's call getMap. It's a function which does not modify the state, so we can call it through a callViewFunction interface."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'async function getBoard() {\n  const result = await near.callViewFunction(\n    myAccountId, // we are using your default nearstudio account\n    studioConfig.contractName, // contract name associated with this fiddle\n    "getMap", // method name\n    {}); // parameters - no parameters here\n  return result;\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Call this function from runTest() and try running it! You should be able to get the game state now!"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Second, let's try to modify the game state! Add this to runTest() and try running it!"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'async function runTest() {\n  ...\n  const setCoordsArgs = {\n    "coords": "2,1",\n    "value": "40AB3C" \n  };\n  await near.scheduleFunctionCall(\n    0, myAccountId,\n    studioConfig.contractName,\n    "setCoords",\n    setCoordsArgs);\n  ...\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"step-3----make-a-simple-ui"}},"Step 3 -- Make a simple UI"),o.a.createElement(r.MDXTag,{name:"p",components:n},"At this point, we are making a UI. All the blockchain work is done! This example uses a very simple plain javascript UI.\nWe need a few more tweaks to main.js to include some UI javascript - add the following to main.js."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'function loadBoardAndDraw() { \n  const board = getBoard().then((fullMap) => {\n  var splitByRow = fullMap.split(";");\n    var canvas = document.getElementById("myCanvas");\n    var ctx = canvas.getContext("2d");\n    for (var x = 0; x < splitByRow.length; x++) {\n      var splitByCol = splitByRow[x].split(",");\n      for (var y = 0; y < splitByCol.length; y++) {\n        ctx.fillStyle = "#" + splitByCol[y];\n        ctx.fillRect(x*10, y*10, 10, 10);\n      }\n    }\n  });\n}\n\nfunction getMousepos(canvas, evt){\n  var rect = canvas.getBoundingClientRect();\n  return {\n    x: evt.clientX - rect.left,\n    y: evt.clientY - rect.top\n  };\n}\n\nfunction myCanvasClick(e) {\n  const canvas = document.getElementById("myCanvas");\n  const ctx = canvas.getContext("2d");\n  const position = getMousepos(canvas, e);\n  const x = Math.floor(position.x/10);\n  const y = Math.floor(position.y/10);\n\n  const coords = x + "," + y;\n  const rgb = document.getElementById(\'picker\').value;\n  ctx.fillStyle = "#" + rgb;\n  ctx.fillRect(x*10, y*10, 10, 10);\n\n\n  var readMethodName = "setCoords";\n  args = { coords: coords, value: rgb };\n  nearjs.scheduleFunctionCall(\n    0, myAccountId,\n    studioConfig.contractName, "setCoords", args);\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"We are using a jscolor picker to pick a color. Download ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"http://jscolor.com/"}},"http://jscolor.com/"),", and add jscolor.js to the fiddle under src (or you can copy the file from the working nearplace example)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Replace the content of the main.html file with the following"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'<!DOCTYPE html>\n<html lang="en">\n  <head>\n  <meta charset="utf-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  \x3c!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --\x3e\n  <script src="./near.js"><\/script>\n  <script src="./main.js"><\/script>\n  <script src="jscolor.js"><\/script>\n  <span id="container"></span>\n  <title>NEAR PLACE</title>\n  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">\n  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css">\n  <style>\n    .glyphicon-refresh-animate {\n            -animation: spin .7s infinite linear;\n            -webkit-animation: spin2 .7s infinite linear;\n    }\n\n    @-webkit-keyframes spin2 {\n            from { -webkit-transform: rotate(0deg);}\n            to { -webkit-transform: rotate(360deg);}\n    }\n\n    @keyframes spin {\n            from { transform: scale(1) rotate(0deg);}\n            to { transform: scale(1) rotate(360deg);}\n    }\n  </style>\n  </head>\n  <body style="padding-top: 70px; padding-bottom: 30px;">\n    \x3c!-- Fixed navbar --\x3e\n    <nav class="navbar navbar-inverse navbar-fixed-top">\n        <div class="container">\n        <div class="navbar-header">\n            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">\n            <span class="sr-only">Toggle navigation</span>\n            <span class="icon-bar"></span>\n            <span class="icon-bar"></span>\n            <span class="icon-bar"></span>\n            </button>\n            <a class="navbar-brand" href="#">NEAR PLACE</a>\n        </div>\n        <div id="navbar" class="navbar-collapse collapse">\n            <ul class="nav navbar-nav">\n            <li class="active"><a href="#">Home</a></li>\n            <li><a href="#about">About</a></li>\n            <li><a href="#contact">Contact</a></li>\n            </ul>\n        </div>\x3c!--/.nav-collapse --\x3e\n        </div>\n    </nav>\n\n    <div class="container" role="main">\n        <div class="jumbotron">\n            <h1>PLACE</h1>\n            <p>Imagine drawing <b>forever</b> on the blockchain.</p>\n          </div>\n        <div align="center">\n        <canvas\n          id="myCanvas"\n          class="drawingboard",\n          width="100"\n          height="100"\n          onclick="myCanvasClick(event);"\n          style="border:1px solid #000000;"></canvas>\n        </canvas>\n        </div>\n        <div align="center">\n        <input class="jscolor" id="picker" value="ab2567">\n    </div>\n    <script>\n        const baseUrl = "https://studio.nearprotocol.com/contract-api/";\n        // TODO: Pass contract name from studio somehow\n        const contractName = "studio-BVvm8vx";\n        loadBoardAndDraw();\n        setInterval(loadBoardAndDraw, 10000);\n    <\/script>\n  </body>\n</html>\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"The game should now work and show the UI in nearstudio when you run it!"))}}])&&i(t.prototype,a),s&&i(t,s),n}();d.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=src-tutorials-multiplayergame.7bb43997b2a652746096.js.map